"""
**Ejercicio: Detecci√≥n de Jugadores con Potencial Profesional - Clasificaci√≥n con SVM**

**üß† Contexto:**
Imagina que trabajas en una plataforma de eSports y tu equipo est√° desarrollando un sistema de scouting para detectar jugadores con potencial profesional en base a sus estad√≠sticas de juego.
Tu tarea es construir un modelo de clasificaci√≥n usando SVM (Support Vector Machine) que, dada la informaci√≥n de un jugador, prediga si tiene el perfil de jugador profesional (1) o no (0).

**üìã Objetivo del ejercicio:**
Implementar un clasificador que:
* Use datos simulados de jugadores (partidas ganadas, horas jugadas, precisi√≥n, velocidad de reacci√≥n, estrategia).
* Entrene un modelo de SVM con scikit-learn.
* Clasifique a nuevos jugadores como "pro" o "casual".
* Eval√∫e el modelo con m√©tricas de precisi√≥n.

**üìÅ Datos de entrada:**
Cada jugador se representa con las siguientes caracter√≠sticas (todas normalizadas entre 0 y 1):
* Partidas ganadas (Winning Rate)
* Horas jugadas (Hours Played)
* Precisi√≥n (Accuracy)
* Velocidad de reacci√≥n (Reaction Time - lower is better, but normalized here so higher is better)
* Estrategia (Game Sense/Strategy)

**üß™ Ejemplo de datos:**
(La clase GameSimulator genera estos datos)

**Salida esperada (aproximada):**
Jugador profesional:
Precisi√≥n del modelo: 0.97

Nuevo jugador (potencialmente profesional):
  Estad√≠sticas: [0.8  0.9  0.95 0.88 0.7 ]
  Predicci√≥n: Profesional

Nuevo jugador (potencialmente casual):
  Estad√≠sticas: [0.3  0.4  0.5  0.35 0.2 ]
  Predicci√≥n: Casual

**üõ†Ô∏è Tareas a realizar:**
Implementa la clase ProPlayerClassifier con los m√©todos:
* train(X, y) para entrenar el modelo.
* predict(player_stats) para predecir si un jugador es profesional.
* evaluate(X_test, y_test) para evaluar la precisi√≥n del modelo.
Usa sklearn.svm.SVC como modelo base.
Prueba el modelo con al menos 2 predicciones distintas.
Eval√∫a el rendimiento con accuracy_score.

**üéØ Objetivo de aprendizaje:**
Practicar con el algoritmo de m√°quinas de vector de soporte SVM
"""
import numpy as np  # Importa la biblioteca NumPy para operaciones num√©ricas y manejo de arrays.
from sklearn.model_selection import train_test_split  # Importa la funci√≥n para dividir datos en entrenamiento y prueba.
from sklearn.svm import SVC  # Importa la clase SVC para implementar el modelo de M√°quinas de Vectores de Soporte (SVM).
from sklearn.metrics import accuracy_score  # Importa la funci√≥n para calcular la precisi√≥n del modelo.

class GameSimulator:
    """Simula la generaci√≥n de datos de jugadores de eSports."""
    def __init__(self, n_casual=80, n_pro=20, random_state=42):
        """
        Inicializa el simulador de datos.

        Args:
            n_casual (int): N√∫mero de jugadores casuales a generar.
            n_pro (int): N√∫mero de jugadores profesionales a generar.
            random_state (int): Semilla para el generador de n√∫meros aleatorios para reproducibilidad.
        """
        self.n_casual = n_casual
        self.n_pro = n_pro
        self.random_state = random_state
        np.random.seed(self.random_state)  # Establece la semilla aleatoria para asegurar resultados consistentes.

    def run(self):
        """
        Genera datos simulados de jugadores casuales y profesionales.

        Returns:
            tuple: Una tupla que contiene:
                - X (np.ndarray): Matriz de caracter√≠sticas de todos los jugadores.
                - y (np.ndarray): Vector de etiquetas (0 para casual, 1 para profesional).
        """
        # Genera datos aleatorios para jugadores casuales (etiqueta 0).
        casual_ganadas = np.random.rand(self.n_casual) * 0.6  # Partidas ganadas (rango m√°s bajo).
        casual_horas = np.random.rand(self.n_casual) * 0.5  # Horas jugadas (rango m√°s bajo).
        casual_precision = np.random.rand(self.n_casual) * 0.7  # Precisi√≥n (rango moderado).
        casual_reaccion = np.random.rand(self.n_casual) * 0.6  # Velocidad de reacci√≥n (rango moderado).
        casual_estrategia = np.random.rand(self.n_casual) * 0.5  # Estrategia (rango m√°s bajo).
        casual_labels = np.zeros(self.n_casual)  # Asigna la etiqueta 0 (casual) a estos jugadores.

        # Genera datos aleatorios para jugadores profesionales (etiqueta 1).
        pro_ganadas = 0.4 + np.random.rand(self.n_pro) * 0.6  # Partidas ganadas (rango m√°s alto).
        pro_horas = 0.5 + np.random.rand(self.n_pro) * 0.5  # Horas jugadas (rango m√°s alto).
        pro_precision = 0.3 + np.random.rand(self.n_pro) * 0.7  # Precisi√≥n (rango m√°s alto).
        pro_reaccion = 0.4 + np.random.rand(self.n_pro) * 0.6  # Velocidad de reacci√≥n (rango m√°s alto).
        pro_estrategia = 0.5 + np.random.rand(self.n_pro) * 0.5  # Estrategia (rango m√°s alto).
        pro_labels = np.ones(self.n_pro)  # Asigna la etiqueta 1 (profesional) a estos jugadores.

        # Combina las caracter√≠sticas de ambos tipos de jugadores en una sola matriz X.
        X = np.vstack((
            np.vstack((casual_ganadas, casual_horas, casual_precision, casual_reaccion, casual_estrategia)).T,
            np.vstack((pro_ganadas, pro_horas, pro_precision, pro_reaccion, pro_estrategia)).T
        ))
        # Combina las etiquetas de ambos tipos de jugadores en un solo vector y.
        y = np.concatenate((casual_labels, pro_labels))

        return X, y  # Devuelve las caracter√≠sticas y las etiquetas generadas.

class ProPlayerClassifier:
    """Clasificador para detectar jugadores con potencial profesional usando SVM."""
    def __init__(self, random_state=42):
        """
        Inicializa el clasificador SVM.

        Args:
            random_state (int): Semilla para el generador de n√∫meros aleatorios del modelo para reproducibilidad.
        """
        self.model = SVC(kernel='rbf', random_state=random_state)  # Crea una instancia del modelo SVM con kernel RBF.

    def train(self, X, y):
        """
        Entrena el modelo SVM con los datos proporcionados.

        Args:
            X (np.ndarray): Matriz de caracter√≠sticas de los jugadores.
            y (np.ndarray): Vector de etiquetas (0 para casual, 1 para profesional).
        """
        self.model.fit(X, y)  # Entrena el modelo SVM utilizando los datos de entrenamiento.

    def predict(self, player_stats: list) -> int:
        """
        Predice si un jugador es profesional basado en sus estad√≠sticas.

        Args:
            player_stats (list): Una lista de 5 caracter√≠sticas del jugador
                                 (partidas ganadas, horas jugadas, precisi√≥n,
                                  velocidad de reacci√≥n, estrategia).

        Returns:
            int: 1 si el jugador se predice como profesional, 0 si no.
        """
        # Convierte la lista de estad√≠sticas a un array de NumPy antes de usar reshape.
        player_stats_np = np.array(player_stats)
        # Realiza la predicci√≥n utilizando el modelo entrenado y redimensiona las estad√≠sticas para que sean una sola muestra.
        return self.model.predict(player_stats_np.reshape(1, -1))[0]

    def evaluate(self, X_test, y_test):
        """
        Eval√∫a la precisi√≥n del modelo en un conjunto de prueba.

        Args:
            X_test (np.ndarray): Matriz de caracter√≠sticas del conjunto de prueba.
            y_test (np.ndarray): Vector de etiquetas del conjunto de prueba.

        Returns:
            float: La precisi√≥n del modelo en el conjunto de prueba.
        """
        y_pred = self.model.predict(X_test)  # Realiza predicciones en el conjunto de prueba.
        accuracy = accuracy_score(y_test, y_pred)  # Calcula la precisi√≥n comparando las predicciones con las etiquetas reales.
        return accuracy  # Devuelve la precisi√≥n del modelo.

# Ejemplo de uso (se ejecuta cuando el script se llama directamente)
if __name__ == "__main__":
    # Simular datos de jugadores utilizando la clase GameSimulator.
    simulator = GameSimulator()
    X, y = simulator.run()

    # Dividir los datos generados en conjuntos de entrenamiento (70%) y prueba (30%).
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    # Crear una instancia del clasificador ProPlayerClassifier.
    classifier = ProPlayerClassifier(random_state=42)

    # Entrenar el clasificador utilizando los datos de entrenamiento.
    classifier.train(X_train, y_train)

    # Evaluar la precisi√≥n del modelo utilizando el conjunto de prueba y el m√©todo evaluate.
    accuracy = classifier.evaluate(X_test, y_test)
    print(f"Precisi√≥n del modelo: {accuracy:.2f}\n")

    # Probar el clasificador con las estad√≠sticas de un nuevo jugador (potencialmente profesional).
    new_player_pro_list = [0.8, 0.9, 0.95, 0.88, 0.7]
    prediction_pro = classifier.predict(new_player_pro_list)
    print("Nuevo jugador (potencialmente profesional):")
    print(f"  Estad√≠sticas: {new_player_pro_list}")
    print(f"  Predicci√≥n: {'Profesional' if prediction_pro == 1 else 'Casual'}\n")

    # Probar el clasificador con las estad√≠sticas de otro nuevo jugador (potencialmente casual).
    new_player_casual_np = np.array([0.3, 0.4, 0.5, 0.35, 0.2])
    prediction_casual = classifier.predict(new_player_casual_np.tolist()) # Se pasa como lista para demostrar la robustez.
    print("Nuevo jugador (potencialmente casual):")
    print(f"  Estad√≠sticas: {new_player_casual_np.tolist()}")
    print(f"  Predicci√≥n: {'Profesional' if prediction_casual == 1 else 'Casual'}\n")
