

# üì± Contexto
# Eres parte de un equipo de an√°lisis de una startup que lanza apps m√≥viles.
# Se te ha asignado la tarea de construir un modelo que pueda predecir si una app ser√° exitosa o no
# en funci√≥n de sus m√©tricas iniciales.
# La empresa ha recopilado datos de otras apps anteriores, tanto exitosas como fallidas,
# y quiere automatizar este an√°lisis con Machine Learning.

# üéØ Objetivo
# Crea un sistema en Python que permita:
# - Representar los datos de una app.
# - Preparar un conjunto de datos a partir de m√∫ltiples apps.
# - Entrenar un modelo de regresi√≥n log√≠stica con scikit-learn.
# - Predecir si una app ser√° exitosa.
# - De forma opcional, mostrar la probabilidad de √©xito.

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
import numpy as np

class App:
    """Representa una app m√≥vil con sus caracter√≠sticas."""
    def __init__(self, app_name, monthly_users, avg_session_length, retention_rate, social_shares, success=None):
        """
        Inicializa una instancia de la clase App.

        Args:
            app_name (str): Nombre de la aplicaci√≥n.
            monthly_users (int): N√∫mero de usuarios mensuales.
            avg_session_length (float): Duraci√≥n media de las sesiones en minutos.
            retention_rate (float): Tasa de retenci√≥n de usuarios (entre 0 y 1).
            social_shares (int): N√∫mero de veces que se ha compartido en redes sociales.
            success (int, opcional): Etiqueta de √©xito (1) o fracaso (0). Defaults to None para nuevas apps.
        """
        self.app_name = app_name
        self.monthly_users = monthly_users
        self.avg_session_length = avg_session_length
        self.retention_rate = retention_rate
        self.social_shares = social_shares
        self.success = success

    def to_features(self):
        """
        Devuelve una lista de caracter√≠sticas num√©ricas de la app.

        Returns:
            list: Lista con los valores de monthly_users, avg_session_length, retention_rate y social_shares.
        """
        return [self.monthly_users, self.avg_session_length, self.retention_rate, self.social_shares]

class AppDataset:
    """Representa un conjunto de datos de apps."""
    def __init__(self, apps):
        """
        Inicializa una instancia de la clase AppDataset.

        Args:
            apps (list): Lista de objetos App.
        """
        self.apps = apps

    def get_feature_matrix(self):
        """
        Devuelve una matriz de caracter√≠sticas a partir de la lista de apps.

        Returns:
            list: Lista de listas, donde cada lista interna representa las caracter√≠sticas de una app.
        """
        return [app.to_features() for app in self.apps]

    def get_target_vector(self):
        """
        Devuelve un vector de etiquetas (success) para las apps con etiqueta conocida.

        Returns:
            list: Lista con los valores de √©xito (1 o 0) de las apps que tienen esta informaci√≥n.
        """
        return [app.success for app in self.apps if app.success is not None]

class SuccessPredictor:
    """Encargado de entrenar y usar el modelo de regresi√≥n log√≠stica."""
    def __init__(self):
        """
        Inicializa una instancia de la clase SuccessPredictor.
        Crea un modelo de regresi√≥n log√≠stica y un escalador est√°ndar.
        """
        self.model = LogisticRegression()
        self.scaler = StandardScaler()

    def train(self, dataset):
        """
        Entrena el modelo de regresi√≥n log√≠stica utilizando un AppDataset.

        Args:
            dataset (AppDataset): Objeto AppDataset que contiene los datos de entrenamiento.
        """
        features = dataset.get_feature_matrix()
        target = dataset.get_target_vector()
        # Comprueba si hay datos de √©xito para entrenar el modelo
        if not target:
            print("Advertencia: No hay datos de √©xito para entrenar el modelo.")
            return
        # Escala las caracter√≠sticas utilizando StandardScaler
        scaled_features = self.scaler.fit_transform(features)
        # Entrena el modelo de regresi√≥n log√≠stica con las caracter√≠sticas escaladas y las etiquetas de √©xito
        self.model.fit(scaled_features, target)

    def predict(self, app):
        """
        Predice si una app ser√° exitosa (1) o no (0).

        Args:
            app (App): Objeto App para el cual se quiere realizar la predicci√≥n.

        Returns:
            int: 1 si se predice √©xito, 0 si se predice fracaso.
        """
        # Obtiene las caracter√≠sticas de la app y las redimensiona
        features = np.array(app.to_features()).reshape(1, -1)
        # Escala las caracter√≠sticas utilizando el mismo escalador que se us√≥ para el entrenamiento
        scaled_features = self.scaler.transform(features)
        # Realiza la predicci√≥n con el modelo entrenado y devuelve el resultado
        return self.model.predict(scaled_features)[0]

    def predict_proba(self, app):
        """
        Devuelve la probabilidad estimada de √©xito de la app.

        Args:
            app (App): Objeto App para el cual se quiere obtener la probabilidad de √©xito.

        Returns:
            float: Probabilidad de √©xito (valor entre 0 y 1).
        """
        # Obtiene las caracter√≠sticas de la app y las redimensiona
        features = np.array(app.to_features()).reshape(1, -1)
        # Escala las caracter√≠sticas utilizando el mismo escalador que se us√≥ para el entrenamiento
        scaled_features = self.scaler.transform(features)
        # Obtiene las probabilidades de la app perteneciendo a cada clase
        probability = self.model.predict_proba(scaled_features)[0][1]
        return probability

# Ejemplo de uso
# Datos de entrenamiento: lista de objetos App con informaci√≥n de apps anteriores y su √©xito
apps = [
    App("FastChat", 10000, 12.5, 0.65, 1500, 1),
    App("FitTrack", 500, 5.0, 0.2, 50, 0),
    App("GameHub", 15000, 25.0, 0.75, 30
